# IHW_Arbuzova

# HW_UE_1

Арбузова Юлия

**Алгоритм генерации комнат**

Для реализации алгоритма генерации комнат быо создан объект Room manager. Логику будем прописывать в событии BeginPlay. Для начала мы определяем количество комнат при помощи функции Random Integer, где во входные параметры мы задаем минимально количество комнат (по условию 6) и максимальное (по условию 10), устанавливаем значение в переменную Room Count, которую будем использовать в цикле.

Запускаем наш цикл, длина которого равная значению RoomCount (сгенерированному рандомно).

1. Если индекс равен 0, создаем начальную комнату, используя Spawn Actor (для начальной комнаты был создан отдельный класс, так как данный объект содержит выходы только с одной стороны). Чтобы соpдать объект в праильном месте заводим переменную Place to Spawn, которую будем изменять с течением генерации новых комнат. После создания каждой комнаты как раз будем менять переменную Place to Spawn, продвигая её дальше по оси X.

2. Если индекс не равен 0 и не являемся последней итерацией цикла, то будем создавать обычные комнаты, представленные объектом Room. Такие объекты имеют два входа и два выхода. Выходы подписаны, чтобы игрок мог понять где будет сложная комната, а где легкая. Аналогично спавним объект на местность и сдвигаем параметр Place to Spawn.

3. Если это последняя итерация цикла, спавним объект Room End, который имеет вид последней комнаты. Отличительными особенностями этой комнаты является наличие входов только с одной стороны и объект, обозначающий выигрыш (в моём случае золотая капсула).

Таким образом в начале игры мы сразу генерируем игроую область включающую в себя пустые комнаты в количестве, которое было рандомно сгенерировано. В последней комнате находится конечная цель, все проходы открыты и ловушки ещё не созданы.

**Алгоритм генерации содержимого комнат**

Для того чтобы перейти к содержимому комнат необходимо обговорить, что на выходы комнаты налолжены Collision Box, для того чтобы обрабатывать входи игрока в следующую комнату. Так как только после того ка сработает событие на Collision Box сгенерируется наполнение этой комнаты.

Каждая комната в зависимости от выходы имеет два Collision Box. Один называется ExitHard и обозначает вход в сложную комнату и ExitLight, для обозначения легкой комнаты. Когда ользователь попадает в Collision Box срабатывают соответвующие необходимой сложности функции, которые генирируют объекты внутри комнаты.

**_Для легкой комнаты_**

Задаём необходимое количество ловушек каждого вида (6 штук). В цикле создаем подвижные ловушки при помощи функции Spawn Actor, место куда будет спавниться ловушка выбирается рандомно, используя значения minX и maxX, которые будем определять относительно положения actor (используем функцию Get Actor Location), параматер Y для таких ловушек не меняется, так как для их движения используется TimeLine. После того как мы спавним объект мы запускаем событие Move Slow, которое запустит ловушки со скоростью необходимой для легкой комнаты. После окончания цикла, соответвеннно когда мы заспавнили все движущиеся ловушки, вызываем функцию которая запускает статичные ловушки (их столько же сколько и подвижных). Для статической ловушки создан отдельный объект. Место для спавна ловушки тоже задается рандомно (рандомно в рамках размера комнаты, отдельно задавая значение для X и Y). Далее, так как мы уже задали тип комнаты, чтобы случайно ещё раз не создавать новые лишние ловушки мы удалим Collision Box входов, которые мы уже прошли

**_Для сложной комнаты_**

Задаём необходимое количество ловушек каждого вида (8 штук). В цикле создаем подвижные ловушки при помощи функции Spawn Actor, место куда будет спавниться ловушка выбирается рандомно, используя значения minX и maxX, которые будем определять относительно положения actor (используем функцию Get Actor Location), параматер Y для таких ловушек не меняется, так как для их движения используется TimeLine. После того как мы спавним объект мы запускаем событие Move 1, которое запустит ловушки со скоростью необходимой для сложной комнаты (соответсвенно скорость больше чем в легкой комнате). После окончания цикла, соответвеннно когда мы заспавнили все движущиеся ловушки, вызываем функцию которая запускает статичные ловушки (их столько же сколько и подвижных). Для статической ловушки создан отдельный объект. Место для спавна ловушки тоже задается рандомно (рандомно в рамках размера комнаты, отдельно задавая значение для X и Y). А также спавним объект Survive, который будет восстанавливать здоровье игроку. Далее, так как мы уже задали тип комнаты, чтобы случайно ещё раз не создавать новые лишние ловушки мы удалим Collision Box входов, которые мы уже прошли

Теперь необходимо провгорить то, на входе в новую комнату стоят Collision Boxы, который будут блокировать входы. Когда игрок попадает в эту область за игроком спавнится стена, которая закрывает доступ к прошлой комнате

**Как задается сложность уровня**

Соответственно, если подытожить, сложность комнаты задается количеством подвижных и статичных ловушек и скоростью подвижных ловушек.

Чтобы усложнить тот уровень или, наоброт, сделать его легче, можно изменить параметры того сколько здоровья отнимают ловушки, сколько прибавлять здоровья будет восстанавливающий объект, количество ловушек в легкой и слоных комнатах

**Окончание игры**

Игра пройдена если игрок дошёл до последней комнаты и вошел в Collision Box золотой капсулы. На данный момент в конце просто выводится надпись You Win!

**Механика ловушек**

Движение подвижных ловушек задается использование TimeLine. Мы создаем TimeLime, который выдает значение от 0 до 1 за определенное количество секунд. Для того, чтобы задать более медленную скорость ловушки мы создаем новый TimeLine и устанавливаем ему большее количество секунд. Задаем определнное расстояние и наш объект будет двигаться туда-сюда между двумя точками (используем Flip Flop)

Чтобы ловушки отнимали жизни мы создаём у объекта Collision Box, при попадании в который у человека будет отниматься определенное окличество здоровья (через переменную Health игрока). Ананлогичным образом работает восстанавливающий объект, но теперь он будет добавлять определнное количество здоровья

**В случае смерти игрока**

Если у игрока заканчивается здоровья игрок переносится в начало уровня, соотвенно занаво сгенерируется определнное оклчетсво комнат, которые изначально будут пустыми, и игрок будет заново заходить в комнаты и ловушки будут спавниться новым образом.

**Индикатор жизни**

На данный момент у человека здороье равно 100, каждая ловушка отнимает по 10, а восстанавливающий элемент увеличивает на 30. Чтобы свзяать все эти изменения с нашим индикатором был создан UI элемент типа Proggress Bar. На нем отмечается процентное соотношение нынешнего значения параметра Health человека от максимального количества (в данном случае 100)

Если будут проблемы с файлом или будут вопросы, пишите в тг @Julia_Arbzw









